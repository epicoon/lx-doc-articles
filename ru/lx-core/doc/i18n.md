[Английская версия (English version)](https://github.com/epicoon/lx-doc-articles/blob/master/en/lx-core/doc/i18n.md)

# Интернационализация

## Оглавление
* [Общая информация](#base)
* [Интернационализация сервисов и плагинов](#services)
* [Интернационализация js-модулей](#js-modules)
* [Синтаксис использования ключей интернационализации](#syntax)


<a name="base"><h2>Общая информация</h2></a>

Список используемых приложением языков задается в файле `path/to/project/lx/data/languages.php`. Данный файл возвращает ассоциативный массив, где ключи - метки языков, значения - названия (которые также являются метками для интернационализации).

Интернационализация непосредственно осуществляется для сервисов, плагинов и js-модулей.

Для осуществления механизма перевода используется карта интернационализации. Карта включает:
* файл с картой интернационализации уровня приложения
* файл с картой интернационализации уровня сервиса
* файл с картой интернационализации уровня плагина (при интернационализации на уровне плагина)
* файл с картой интернационализации для js-модуля
Файл с картой интернационализации (для любого уровня) должен иметь один из форматов: `yaml`, `php` или `json`. Он должен содержать ассоциативный массив, в котором ключами являются метки используемых приложением языков, значениями - ассоциативные массивы с наборами переводов.

> Совет: если карта большая и ее нужно разбить на несколько файлов, проще всего это сделать в формате `yaml`, используя ссылку на файл: `en-EN: ^ref en-EN.yaml`.

Пример карты в формате `yaml`:
```yaml
en-EN:
  OK: OK
  Close: Close
  Yes: Yes
  No: No
ru-RU:
  OK: Применить
  Close: Закрыть
  Yes: Да
  No: Нет
```


<a name="services"><h2>Интернационализация сервисов и плагинов</h2></a>

По умолчанию файл интернационализации имеет имя `i18n.(yaml|php|json)` и располагается в корневом каталоге своего уровня.<br>
Путь и имя файла можно задать в файле конфигурации соответствующего уровня (приложения, сервиса, плагина) по ключу `i18nFile`.<br>

За реализацию алгоритма интернационализации отвечает специальный объект, экземпляр класса  (или унаследованного от него), в зависимости от уровня:
* для приложения - `lx\I18nApplicationMap`
* для сервиса - `lx\I18nServiceMap`
* для плагина - `lx\I18nPluginMap`
При локализации на уровне приложения, доступен как поле `$app->i18n`. На уровне сервиса, доступен как поле сервиса `$service->i18n`. На уровне плагина - как поле плагина `$plugin->i18n`.<br>
Данный класс можно изменить в файле конфигурации соответствующего уровня (сервиса или плагина) по ключу `i18nMap`.<br>
Указать информацию о классе можно несколькими способами:
```yaml
# Указание имени класса
i18nMap: ClassName

# Указание ассоциативного массива с именем класса и параметрами для его создания
i18nMap:
  class: ClassName
  param1: value1
  param2: value2

# Указание ассоциативного массива с именем класса
# и параметрами для его создания явно выделенными в отденый массив для наглядности
i18nMap:
  class: ClassName
  params:
    param1: value1
    param2: value2
```

В большинстве случаев, при разработке своих плагинов и сервисов, функционала стандартных классов вполне достаточно. Но представим ситуацию - используется сторонний сервис `foreign/service`, который не поддерживает интернационализацию на языки, необходимые нашему приложению. Решение - создаем файл с картой интернационализации на нужные нам языки. Чтобы эта карта использовалась сервисом, наследуем класс от `lx\I18nServiceMap`:
```php
// Код PHP

namespace some\nmsp;

use lx\I18nServiceMap;

class Translater extends I18nServiceMap {
	public function files() {
		return [
			'path/to/map.yaml',
		];
	}
}
```
После чего используем возможность инъекции в конфигурацию сервиса. В конфигурации приложения добавляем:
```yaml
# Ключ конфигурации приложения для инъекций в конфиги сервисов и плагинов
configInjection:
  # Имя сервиса, в который осуществляем инъекцию
  foreign/service:
    # По ключу для определения в конфигурации сервиса 
    i18nMap: some\nmsp\Translater
```
Все старые карты также будут использоваться, добавится использование новой карты.

Другой способ решения проблемы - если существует пакет, который уже локализует нужный Вам сервис. Устанавливаем его, допустим он называется `foreign/service-i18n`. Устроен он будет по похожему принципу, что указан выше. Допустим, в качестве класса-переводчика он предоставляет `foreignI18n\Translater`. Но что делать, если метки языков не совпадают с Вашими метками? Решение - в конфигурации приложения, совершая инъекцию в конфигурацию сервиса, указываем соответсвия меток:
```yaml
configInjection:
  foreign/service:
    i18nMap:
      class: foreignI18n\Translater
      tags:
        # ключ - метка переводчика, значение - Ваша метка
        la: la-LA
```

<a name="js-modules"><h2>Интернационализация js-модулей</h2></a>
Решить задачу интернационализации js-модуля не просто, а очень просто. Нужен файл с картой, и в коде модуля, используя синтаксис определения данных для модуля, по ключу `i18n` просто указываем путь к файлу.
Пример:
```js
#lx:module SomeName;
#lx:module-data {
    i18n: path/to/i18n.yaml
};

class SomeName {
    // ... code
}
```
Для единообразия рекомендуется файл называть `i18n.yaml` и располагать его в каталоге с кодом модуля. Тогда определение данных для модуля выглядит предельно лаконично:
```js
#lx:module-data { i18n: i18n.yaml };
```
[Подробнее о js-модулях](https://github.com/epicoon/lx-doc-articles/blob/master/ru/lx-core/doc/js-modules.md).


<a name="syntax"><h2>Синтаксис использования ключей интернационализации</h2></a>
Допустим, имеем карту интернационализации:
```yaml
en-EN:
  OK: OK
  Close: Close
ru-RU:
  OK: Применить
  Close: Закрыть
```
Корректно настроили её использование. Как использовать эти ключи в коде сниппета? Следующий пример это продемонстрирует:
```js
#lx:use lx.Button;

let button1 = new lx.Button({ text: #lx:i18n(OK) });
let button2 = new lx.Button({ text: #lx:i18n(Close) });
```
