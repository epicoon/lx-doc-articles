[Английская версия (English version)](https://github.com/epicoon/lx-doc-articles/blob/master/en/app-dev/expl1/3_figures.md)

### Шаг 3. Описание фигур

Опишем фигуры и создадим класс, который будет фигуры представлять.

Создадим для фигур отдельный каталог `services/tetris/module/game/frontend/figures`.

Начнем с конфигурации фигур. Фигуры отличаются друг от друга формой и цветом. Так как они могут вращаться, предусмотрим маски всех возможных положений для фигур. И чтобы унифицировать работу с масками, впишем их все в матрицы 4х4. Все необходимые конфигурации представляют из себя данные - текстовое значение для цвета и массивы для масок. Удобно эти данный вынести в отдельный файл. Формат выберем `yaml`, как самый лаконичный (Возможны также `json` и `php` при условии возвращения массива). В каталоге для фигур создаем файл `mapList.yaml` и размещаем в нем следующий код:
```yaml
Cube:
  color: blue
  masks:
    -
      - [0, 1, 1, 0]
      - [0, 1, 1, 0]
      - [0, 0, 0, 0]
      - [0, 0, 0, 0]

Stick:
  color: red
  masks:
    -
      - [0, 1, 0, 0]
      - [0, 1, 0, 0]
      - [0, 1, 0, 0]
      - [0, 1, 0, 0]
    -
      - [0, 0, 0, 0]
      - [1, 1, 1, 1]
      - [0, 0, 0, 0]
      - [0, 0, 0, 0]

Lleft:
  color: violet
  masks:
    -
      - [0, 1, 1, 0]
      - [0, 0, 1, 0]
      - [0, 0, 1, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 0]
      - [0, 1, 1, 1]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 1, 0]
      - [0, 0, 1, 0]
      - [0, 0, 1, 1]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 1]
      - [0, 1, 1, 1]
      - [0, 0, 0, 0]
      - [0, 0, 0, 0]

Lright:
  color: darkviolet
  masks:
    -
      - [0, 1, 1, 0]
      - [0, 1, 0, 0]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 0]
      - [1, 1, 1, 0]
      - [0, 0, 1, 0]
      - [0, 0, 0, 0]
    -
      - [0, 1, 0, 0]
      - [0, 1, 0, 0]
      - [1, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [1, 0, 0, 0]
      - [1, 1, 1, 0]
      - [0, 0, 0, 0]
      - [0, 0, 0, 0]

Tfigure:
  color: yellow
  masks:
    -
      - [0, 1, 0, 0]
      - [0, 1, 1, 0]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 1, 0, 0]
      - [1, 1, 1, 0]
      - [0, 0, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 1, 0, 0]
      - [1, 1, 0, 0]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 0]
      - [1, 1, 1, 0]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]

Zleft:
  color: green
  masks:
    -
      - [0, 0, 1, 0]
      - [0, 1, 1, 0]
      - [0, 1, 0, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 0]
      - [1, 1, 0, 0]
      - [0, 1, 1, 0]
      - [0, 0, 0, 0]

Zright:
  color: lightgreen
  masks:
    -
      - [0, 1, 0, 0]
      - [0, 1, 1, 0]
      - [0, 0, 1, 0]
      - [0, 0, 0, 0]
    -
      - [0, 0, 0, 0]
      - [0, 0, 1, 1]
      - [0, 1, 1, 0]
      - [0, 0, 0, 0]
```

Теперь напишем класс. В том же каталоге создадим файл `Figure.js`. В файле создаем класс `Figure` и, чтобы не засорять глобальное пространство имен (объект `window`), новый класс поместим в пространство имен `tetris` (в дальнейшем поместим в него и прочие нужные нам классы). Сделать это можно при помощи кода `#lx:namespace tetris` сразу после объявления имени класса (или после наследования, если оно имеет место). Пространство имен технически это обычный JS-объект, созданный в глобальном пространстве имен (в объекте `window`), включающий в себя набор классов. Таким образом доступ к классу мы будем иметь как `tetris.Figure`. Сам код:
```js
class Figure #lx:namespace tetris {
}
```

Добавим конструктор. Нам понадабятся поля: `color` чтобы хранить цвет фигуры, `masks` - массив масок, `coords` - где фигура находится на игровой поверхности, `state` - индекс текущей активной маски. Значения для полей `color` и `masks` передаются в конструктор в объекте `params`. Сами значения получим из созданного нами `yaml` файла чуть позже.
```js
	constructor(params) {
		this.color = params.color;
		this.masks = params.masks;

		this.coords = [0, 0];
		this.state = 0;
	}
```

Загрузим данные из `yaml` файла и закэшируем их в статическом поле класса. Полученные данные обернем в класс `lx.Dict` - обычный JS-объект, поддерживающий некоторые методы для проявления свойств словаря (ассоциативного массива). Загрузка из файла типов `yaml`, `json` или `php` (если возвращает массив) осуществляется при помощи использования директивы `#lx:load` и указания пути к файлу. Путь указывается относительно файла, в котором директива вызывается. Но можно использовать псевдонимы приложения, сервиса или модуля; указать абсолютный путь (относительно корня сайта, если путь начинается с символа `/`); или же использовать синтаксис путей относительно сервиса или модуля (н-р `#lx:load {service:some/serviceName}path/in/service`). Сама загрузка осуществляется в процессе сборки на стороне сервера, поэтому на стороне клиента сам путь известен не будет.
```js
	static get map() {
		if (!this.__map) {
			this.__map = new lx.Dict(#lx:load mapList);
		}

		return this.__map;
	}
```

Добавим метод для генерации случайной фигуры. Метод `lx.Math.randomInteger(min, max)` генерирует случайное целое число от `min` до `max` включительно. Поскольку карту конфигураций фигур мы обернули в класс `lx.Dict`, теперь мы может узнать размер карты методом `len()`, несмотря на то, что это ассоциативный массив, а также можем получить ключ по условному индексу (порядку, в котором ключ находится в массиве).
```js
	static getRand() {
		var map = this.map;
		var rand = lx.Math.randomInteger(0, map.len() - 1);
		var key = map.nthKey(rand);
		return new this(map[key]);
	}
```

Следующий метод будет возвращать карту координат ячеек, занимаемых фигурой, в системе отсчета игровой поверхности. Таким образом можно будет узнать какие ячейки занимает фигура в данный момент, либо, если передать координаты, какие бы она занимала.
```js
	mask(coords) {
		if (coords === undefined)
			coords = this.coords;
		var result = [],
			index = 0,
			currentMask = this.masks[this.state];
		for (var i=0; i<4; i++) {
			for (var j=0; j<4; j++) {
				if (currentMask[i][j] == 0) continue;
				result.push({
					x: j + coords[0],
					y: i + coords[1]
				});
			}
		}
		return result;
	}
```

Добавляем метод для изменения активной маски.
```js
	nextState() {
		this.state++;
		if (this.state == this.masks.len) this.state = 0;
	}
```

Добавляем метод аналогичный предыдущему, но в обратном направлении.
```js
	prevState() {
		this.state--;
		if (this.state < 0) this.state = this.masks.len - 1;
	}
```

В итоге должен получиться такой код:
```js
class Figure #lx:namespace tetris {
	constructor(params) {
		this.color = params.color;
		this.masks = params.masks;

		this.coords = [0, 0];
		this.state = 0;
	}

	static getRand() {
		var map = this.map;
		var rand = lx.Math.randomInteger(0, map.len() - 1);
		var key = map.nthKey(rand);
		return new this(map[key]);
	}

	static get map() {
		if (!this.__map) {
			this.__map = new lx.Dict(#lx:load mapList);
		}

		return this.__map;
	}

	mask(coords) {
		if (coords === undefined)
			coords = this.coords;
		var result = [],
			index = 0,
			currentMask = this.masks[this.state];
		for (var i=0; i<4; i++) {
			for (var j=0; j<4; j++) {
				if (currentMask[i][j] == 0) continue;
				result.push({
					x: j + coords[0],
					y: i + coords[1]
				});
			}
		}
		return result;
	}

	nextState() {
		this.state++;
		if (this.state == this.masks.len) this.state = 0;
	}

	prevState() {
		this.state--;
		if (this.state < 0) this.state = this.masks.len - 1;
	}
}

```

[Следующий шаг](https://github.com/epicoon/lx-doc-articles/blob/master/ru/app-dev/expl1/4_model.md)
